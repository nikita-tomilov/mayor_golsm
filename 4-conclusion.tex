\section{Заключение}

Как показано в статье, разработанная библиотека предоставляет более быструю запись и чтение данных временных рядов по сравнению с SQLite. При этом сохраняется возможность не терять данные в случае непредвиденного отключения питания благодаря механизму коммитлогов. В лучшем случае, эта библиотека работает в 50 раз быстрее, чем SQLite, благодаря уровню хранения $C_0$, который фактически используется как быстрый кэш. Также, эта библиотека работает до двух раз быстрее чем SQLite в операциях записи, благодаря способу организации записи на диск. Однако, это преимущество в скорости записи имеется только в случае, если во временных рядах отметки времени у измерений линейно упорядочены по возрастанию, то есть у следующего пакета данных все отметки времени больше, чем у предыдущего пакета данных. Если это условие не выполняется, запись может быть в несколько раз замедлена, что делает разработанное решение более медленным, чем SQLite. Однако, несмотря на это, преимущество в более быстром чтении из хранилища сохраняется. Управляя размером уровня $C_0$ можно добиться необходимого баланса скорости чтения и используемого объема оперативной памяти.

В случае использования данного решения в условиях логирования данных, когда приложение должно буферизовать данные, поступающие от датчиков, отметки времени всегда будут возрастать. Это убирает потенциальную проблему записи "случайных" по времени данных и делает разработанное решение хорошей альтернативой SQLite, ускоряющей работу с данными.

Потенциальные улучшения разработанной библиотеки включают в себя механизм разделения одного большого SST файла на несколько маленьких, что позволило бы пересортировывать эти файлы быстрее, и механизм более гибкой настройки уровня $C_0$, чтобы размер этого уровня был разным для разных тэгов, для случаев, когда одни тэги записываются гораздо чаще или, наоборот, реже, чем другие.