\section{Сравнение с SQLite}

\subsection{Методология сравнения}

Для сравнения LSM-решения с SQLite была разработана простая система хранения на основе SQLite. Она использует базу данных, состоящую из двух таблиц. Первая таблица называется Measurement и используется для хранения измерений. Каждое измерение представлено своим ключом, временной меткой и значением, а ключ - это первичный идентификатор объекта MeasurementMeta, который хранится во второй таблице. Этот объект хранит имя тега измерения; поэтому можно выполнять поисковые операции с фильтрацией по числовому столбцу вместо текстового столбца. В таблице измерений есть индексы как для ключевого столбца, так и для столбца временной метки.

Для следующих тестов использовалась придуманная синтетическая система. Эта система имеет 10 датчиков, которые производят данные с частотой дискретизации 1 Гц. Для тестов чтения данные для этих 10 тегов были сгенерированы для трех часов измерений. Следовательно, в базе данных SQLite содержатся 108000 записей или точек, или 10800 точек на каждый тег. Библиотека LSM также содержит 108000 записей, разделенных на 10 файлов для каждого тега, по 10800 точек в каждом. Для тестов записи данные для этих 10 тегов генерируются для различных временных диапазонов и затем сохраняются в обоих механизмах хранения.

Для тестирования обоих механизмов хранения использовался стандартный механизм тестирования Go. Он запускает целевой код несколько раз, пока тестовая функция не проработает достаточно долго, чтобы время ее выполнения можно было надежно измерить ~\cite {go_benchmark}. Этот механизм дает результат, который измеряется в ns/op, наносекундах на итерацию; для данных тестов итерация - это один вызов чтения или записи в хранилище.

Все тесты выполнялись на ПК с Intel Core i5-8400 под управлением Ubuntu 18.04, файлы данных для обоих хранилищ хранились на твердотельном накопителе NVMe.

\subsection{Чтение всего диапазона данных}

Этот тест измеряет время считывания для различных временных диапазонов, в то время как операция выполняется для полных трех часов измерений. Результаты этого теста представлены на рисунке ~\ref{fig3}. Как видно, GoLSM примерно в два раза быстрее SQLite по запросам на чтение. Стоит отметить, что уровень $C_0$ LSM-дерева не играет существенной роли в ускорении извлечения данных, поскольку временной диапазон выбирается случайным образом из всех трех часов измерений, в то время как уровень $C_0$ содержит только последние две минуты измерений.

\begin{figure}[h!]
	\centering
	\input{figures/1-read-comparison}
	\caption{Чтение всего диапазона данных.} \label{fig3}
\end{figure}

Как видно, хранилище LSM до 50 раз быстрее, чем SQLite в небольшом диапазоне запросов (51251 нс/операцию для GoLSM и 2517353 нс/операцию для SQLite в диапазоне 25 секунд) и до двух раз быстрее в большом диапазоне запросов (12106688 нс/оп и 24262132 нс/оп в диапазоне 2 ч 15 мин). Эта большая разница может быть вызвана использованием индекса в памяти для каждого файла SST, который работает лучше, чем индексация в SQLite. Повышение эффективности для малого диапазона запросов может быть вызвано тем фактом, что малый запрошенный диапазон с большей вероятностью умещается в пределах уровня $C_0$ дерева LSM, поэтому медленное извлечение из SST не вызывается.

\subsection{Чтение за последние три минуты}

Этот тест измеряет время считывания для различных временных диапазонов, в то время как операция выполняется для последних трех минут измерений. Результаты этого теста показаны на рисунке ~\ref{fig4}. Поскольку уровень $C_0$ LSM-дерева содержит последние две минуты измерений, более вероятно, что запрос будет соответствовать уровню $C_0$ без необходимости запрашивать данные с уровня $C_1$. Таким образом, извлечение данных в два раза быстрее, чем извлечение данных за все три часа измерений, как показано на рисунке ~\ref{fig5}. 

\begin{figure}[!htb]
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/2.1-read-latest}
		}
		\caption{Чтение всего диапазона данных}\label{fig4}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/2.2-read-latest-lsmvslsm}
		}
		\caption{Разница в скорости для разных интервалов.}\label{fig5}
	\end{minipage}
\end{figure}

Если в системе предполагается чтение только самых последних данных, увеличение емкости $C_0$ может значительно улучшить производительность чтения и снизить нагрузку чтения на постоянное хранилище диска.

\subsection{Запись упорядоченных данных}

Этот тест измеряет время записи для различных временных диапазонов. В то время как данные являются упорядоченными, минимальная временная метка следующего записываемого пакета данных всегда больше, чем максимальная временная метка ранее записанного пакета. Это означает, что для каждого SST-файла в GoLSM данные добавляются только в конец SST-файла без необходимости повторять сортировку SST-файла. Результаты этого теста представлены на рисунке ~\ref{fig6}.

\begin{figure}[!htb]
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/3.1-write-comparison-full}
		}
		\label{figure}{(а) Для большого диапазона}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/3.2-write-comparison-small}
		}
		\label{figure}{(б) Для маленького диапазона}
	\end{minipage}
	
	\caption{Запись упорядоченных данных.}\label{fig6}
\end{figure}

На рисунке ~\ref{fig6}, (а) видно, что GoLSM записывает данные в два раза быстрее, чем SQLite, в течение большого записываемого диапазона времени. Однако на рисунке ~\ref{fig6}, (б) для небольшого временного диапазона GoLSM на самом деле медленнее. Причина этого в том, что для LSM измерялось время до момента фактической записи данных в журнал фиксации, а не непосредственно в файлы SST; и когда количество записей в журнале фиксации достигает определенного порога, оно должно быть передано в SST, что вызывает скачки времени записи. Однако для записываемых больших временных диапазонов эти накладные расходы не важны по сравнению с обычно медленными пакетными вставками в SQLite.

Стоит отметить, что для вставки в SQLite необходимо составить оператор SQL Insert, который включает преобразование значения типа double в строку. Эта операция выполняется очень медленно для больших пакетов вставок (пакет из 10 тегов за 30 минут составляет 18000 точек), и использование ORM, такого как GORM, не улучшает ситуацию.

\subsection{Запись неупорядоченных данных}

Этот тест измеряет время записи для различных временных диапазонов, но, поскольку данные являются неупорядоченными, нет никаких гарантий, что все временные метки следующего пакета больше, чем временные метки ранее записанного пакета. Таким образом, пакеты могут быть получены до или после друг друга с точки зрения их временных меток. Это означает, что каждый раз, когда данные передаются из файла журнала фиксации в файлы SST, библиотека должен пересортировать весь файл SST, замедляя процесс записи. Результаты этого теста представлены на рисунке ~\ref{fig7}. Сравнение записи данных в LSM, когда данные являются упорядоченными или неупорядоченными, доступно на рисунке ~\ref {fig8}.

\begin{figure}[!htb]
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/3.3-writerandom}
		}
		\caption{Запись неупорядоченных данных.}\label{fig7}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\resizebox{\textwidth}{!}{%
			\input{figures/3.4-writerandom-lsmvslsm}
		}
		\caption{Разница во времени при записи упорядоченных и неупорядоченных данных.}\label{fig8}
	\end{minipage}
\end{figure}

Как видно на рисунке ~\ref {fig7}, накладные расходы на пересортирование файлов SST при каждой записи данных настолько велики, что они занимают больше времени, чем медленные пакетные вставки в SQLite. Сравнение записи данных с этими накладными расходами с записью данных без накладных расходов показано на рисунке ~\ref{fig8}. Когда временные метки данных всегда линейно увеличиваются, это показывает, что вставки почти в три раза медленнее при записи в большом временном диапазоне (747870163 нс/операцию, или 747 мс, для записи 25 минут линейных данных и 1942545058 нс/операцию, или 1942 мс, для записи 25 минут случайных данных).